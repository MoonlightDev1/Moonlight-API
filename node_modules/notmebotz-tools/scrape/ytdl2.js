const fetch = require('node-fetch');
const { promises: fs } = require('fs');
const { spawn } = require('child_process');
const path = require('path');
const os = require('os');
let uploadFile = require('../lib/uploadFile');

const processMedia = async (buffer, type, quality) => {
    const tempDir = path.join(os.tmpdir(), 'ytdl-temp');
    await fs.mkdir(tempDir, { recursive: true });

    const inputPath = path.join(tempDir, `input-${Date.now()}.${type === 'ytmp3' ? 'mp3' : 'mp4'}`);
    const outputPath = path.join(tempDir, `output-${Date.now()}.${type === 'ytmp3' ? 'mp3' : 'mp4'}`);

    await fs.writeFile(inputPath, buffer);

    return new Promise((resolve, reject) => {
        let ffmpegArgs = type === 'ytmp3' ? [
            '-i', inputPath, '-c:a', 'libmp3lame', '-b:a', `${quality}k`, '-f', 'mp3', outputPath
        ] : [
            '-i', inputPath, '-c:v', 'libx264', '-vf', `scale=-2:${quality}`, '-c:a', 'aac', '-f', 'mp4', outputPath
        ];

        const ffmpeg = spawn('ffmpeg', ffmpegArgs, { stdio: ['ignore', 'ignore', 'ignore'] });

        ffmpeg.on('close', async (code) => {
            try {
                if (code === 0) {
                    const processedBuffer = await fs.readFile(outputPath);
                    await fs.unlink(inputPath);
                    await fs.unlink(outputPath);
                    resolve(processedBuffer);
                } else {
                    throw new Error(`FFmpeg process exited with code ${code}`);
                }
            } catch (err) {
                reject(err);
            }
        });

        ffmpeg.on('error', async (err) => {
            try {
                await fs.unlink(inputPath);
                if (await fs.access(outputPath).then(() => true).catch(() => false)) {
                    await fs.unlink(outputPath);
                }
            } catch {} 
            reject(err);
        });
    });
};

async function ytdl2(url, type = "ytmp4", bitrate) {
    try {
        const infoResponse = await fetch(`https://ytcdn.project-rian.my.id/info?url=${url}`);
        if (!infoResponse.ok) throw new Error(`API error: ${infoResponse.status}`);

        const videoInfo = await infoResponse.json();
        let downloadUrl, selectedQuality;

        if (type === "ytmp3") {
            const requestedBitrate = bitrate || 128;
            const validBitrate = videoInfo.audioBitrates.find(b => b.bitrate === parseInt(requestedBitrate));
            if (!validBitrate) return `${requestedBitrate}kbps is not available, only available bitrates: ${videoInfo.audioBitrates.map(b => b.bitrate).join(', ')}kbps`;

            downloadUrl = `https://ytcdn.project-rian.my.id/audio?url=${url}&bitrate=${requestedBitrate}`;
            selectedQuality = validBitrate;
        } else {
            const requestedResolution = bitrate || 480;
            const validResolution = videoInfo.resolutions.find(r => r.height === parseInt(requestedResolution));
            if (!validResolution) return `${requestedResolution}p is not available, only available resolutions: ${videoInfo.resolutions.map(r => r.height).join(', ')}p`;

            downloadUrl = `https://ytcdn.project-rian.my.id/download?url=${url}&resolution=${requestedResolution}`;
            selectedQuality = validResolution;
        }

        const downloadResponse = await fetch(downloadUrl);
        if (!downloadResponse.ok) throw new Error(`Download failed with status: ${downloadResponse.status}`);

        const buffer = await downloadResponse.buffer();
        const processedBuffer = await processMedia(buffer, type, type === 'ytmp3' ? selectedQuality.bitrate : selectedQuality.height);
        const uploadedFile = await uploadFile(processedBuffer);

        return {
            author: "Herza",
            status: 200,
            data: {
                download: uploadedFile,
                videoInfo: {
                    title: videoInfo.title,
                    uploader: videoInfo.uploader,
                    thumbnail: videoInfo.thumbnail,
                    duration: videoInfo.duration,
                    selectedQuality
                }
            }
        };

    } catch (error) {
        return `Error: ${error.message}`;
    }
}

module.exports = { ytdl2 };
