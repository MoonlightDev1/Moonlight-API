const axios = require('axios');
const fs = require('fs');
const FormData = require('form-data');
const sharp = require('sharp');
const fetch = require('node-fetch');

async function convert(media1, media2) {
    try {
        if (!media1 || !media2) throw new Error("Both media1 and media2 are required");

        const xcode = new Date().getTime();
        let task = await detail(media1, media2, xcode);
        let data = JSON.stringify({
            "task_id": task.data.task_id,
            "request_from": 2
        });

        while (true) {
            let res = await axios.post('https://pixnova.ai/pixnova/api/check_status', data, {
                headers: {
                    'Content-Type': 'application/json',
                    'theme-version': 'YRXBkVsdTpa3Q4lU0qPBjbzQk8Fm3m/9HP4JPm4hIQYkWaeD/ITJvheOdGsZGQTw',
                    'x-code': xcode
                },
            });

            if (res.data.data.status === 2 && res.data.data.result_image) {
                return 'https://art-global.yimeta.ai/' + res.data.data.result_image;
            }

            await sleep(2000);
        }
    } catch (err) {
        console.error("Error in convert:", err);
        return {
            status: 500,
            msg: "Error in processing conversion"
        };
    }
}

async function detail(media1, media2, xcode) {
    try {
        let foto1 = await upload(media1, xcode);
        let foto2 = await upload(media2, xcode);

        if (!foto1 || !foto2) throw new Error("Image upload failed");

        let data = JSON.stringify({
            "source_image": foto1.data,
            "face_image": foto2.data,
            "request_from": 2
        });

        let res = await axios.post('https://pixnova.ai/pixnova/api/generate_face', data, {
            headers: {
                'Content-Type': 'application/json',
                'theme-version': 'YRXBkVsdTpa3Q4lU0qPBjbzQk8Fm3m/9HP4JPm4hIQYkWaeD/ITJvheOdGsZGQTw',
                'x-code': xcode
            },
        });

        return res.data;
    } catch (err) {
        console.error("Error in detail:", err);
        return null;
    }
}

async function upload(media, xcode) {
    try {
        if (!media) throw new Error("No media provided");

        let form = new FormData();
        form.append('file', media, { filename: 'upload.jpg' });

        let res = await axios.post('https://pixnova.ai/pixnova/api/upload_img', form, {
            headers: {
                ...form.getHeaders(),
                'theme-version': 'YRXBkVsdTpa3Q4lU0qPBjbzQk8Fm3m/9HP4JPm4hIQYkWaeD/ITJvheOdGsZGQTw',
                'x-code': xcode
            }
        });

        return res.data;
    } catch (error) {
        console.error("Error in upload:", error);
        return null;
    }
}

async function fcs(mediaPath1, mediaPath2) {
    try {
        if (!mediaPath1 || !mediaPath2) {
            return {
                author: "Herza",
                status: 400,
                msg: "Both mediaPath1 and mediaPath2 are required"
            };
        }

        if (!fs.existsSync(mediaPath1) || !fs.existsSync(mediaPath2)) {
            return {
                author: "Herza",
                status: 400,
                msg: "One or both media files do not exist"
            };
        }

        let media1 = fs.readFileSync(mediaPath1);
        let media2 = fs.readFileSync(mediaPath2);

        let result = await convert(media1, media2);
        let resultRes = await axios.get(result, { responseType: "arraybuffer" });
        let webpBuffer = Buffer.from(resultRes.data);
        let jpegBuffer = await sharp(webpBuffer).jpeg().toBuffer();
        let up = require('../../lib/uploadFile')
        let url = await up(jpegBuffer)
        return {
            author: "Herza",
            status: result.status || 200,
            results: url
        };
    } catch (error) {
        console.error("Error in faceswap:", error);
        return {
            author: "Herza",
            status: 500,
            msg: "Internal server error"
        };
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = { fcs };
